---
date: 2025-06-06
authors:
  - SaranjeetKaur
categories:
  - Technology
tags:
  - Python
  - Logging
---


# **Logging in Python**

When trying to understand what is happening with a Python code or even when debugging, we often end up adding a bunch of `print()` statements all over the code. While this might provide some idea, it is often not structured and is a bit ad-hoc. Python's `logging` module helps provide a more structured approach to tracking events that happen when the software runs. In this blog, we discuss about `logging` and provide some examples of the same.

<!-- more -->

## Levels of logging

To begin with, we can create a logger using `logger = getLogger(__name__)` and then call the logger methods. These methods denotes the level/severity of the event they are tracking. Depending on which level is configured (default is `WARNING`), the events of only that level or higher will be tracked. Below is a list of standard logging levels:

| **Level** | **Numeric value** | **Use** |
| --- | --- | --- |
| NOTSET | 0 | Placeholder  |
| DEBUG | 10 | Helps diagnose problems with detailed information. |
| INFO | 20 | Confirms that things are working as expected. |
| WARNING | 30 | Indicates either something unexpected occurred or there will be a problem in the near future. The software is still working as expected.|
| ERROR | 40 | A more serious problem and the software has not been able to perform some function. |
| CRITICAL | 50 | A serious error which indicates that the program itself may be unable to continue running. |

The [`setLevel`(level)](https://docs.python.org/3/library/logging.html#logging.Logger.setLevel) method is used to set the threshold of a logger to a specified `level`. In the example code below, the logger level is set to INFO which implies, the logger will handle only INFO, WARNING, ERROR, and CRITICAL messages and ignore the DEBUG messages as they are less severe than INFO.

```py
import logging
logger = logging.getLogger('example') # create a logger
logger.setLevel(logging.INFO) # set the logger level to INFO
```

## Handlers

Handlers are used to specify the destination where the log messages generated by loggers should go. For example, the log records maybe send to a log file, or to an email address, or even to the console. It is possible to have multiple handlers for one logger, where each handler sends messages of a specific level to a specific location. The `addHandler()` method can be used to add handler objects to logger objects. Some examples of handlers are listed below:

| **Handler** | **Use** |
| --- | --- |
| StreamHandler | Sends log messages to the console (stdout) or stderr. |
| FileHandler | Sends log messages to a file. |
| RotatingFileHandler | Sends log messages to a file, rotating the file when it reaches a certain size. |
| TimedRotatingFileHandler | Sends log messages to a file, rotating the file at regular time intervals. |
| SMTPHandler | Sends log messages via email. |
| HTTPHandler | Sends log messages to a web server. |
| NullHandler | A handler that does nothing, used to avoid "No handlers could be found" warnings. |

In the example below, we create a logger and add a `StreamHandler` to it. The handler is set to log messages of level INFO and above to the console.

```py
import logging
logger = logging.getLogger('example')  # create a logger
handler = logging.StreamHandler()  # create a handler
handler.setLevel(logging.INFO)  # set the handler level to INFO
logger.addHandler(handler)  # add the handler to the logger
```

Note: Levels can also be set for handlers, which means that the handler will only process messages of that level or higher. If a logger has multiple handlers, each handler can have its own level.

## Demonstration

This demonstration is based on a Python logging exercise by Chris Cave-Ayland, and it is available on [GitHub](https://github.com/cc-a/python_logging_exercises). It covers some common logging scenarios and how to implement them using Python's logging module.

??? "Directory Structure"

    The directory structure for this demonstration is as follows: <!-- markdownlint-disable-line MD046 -->

    ```markdown
    ├── mylib/
    │   ├── __init__.py
    │   ├── module_a.py
    │   └── module_b.py
    ├── README.md
    └── script1.py
    └── script2.py
    .
    .
    .
    └── script10.py
    ```

The `mylib` directory contains two modules, `module_a.py` and `module_b.py`, which contain functions that will be logged. The `script1.py` to `script10.py` files are scripts that call the functions from these modules.

The `mylib/__init__.py` file is used to initialise the `mylib` package and contains the following code:

```py
from logging import getLogger

from .module_a import A
from .module_b import B

logger = getLogger(__name__)


def run():
    print_logging_config()
    a = A()
    a.warn()
    a.info()
    b = B()
    b.warn()
    b.info()


def print_logging_config():
    rl = getLogger()
    print(rl, "handlers:", rl.handlers)
    print(logger, "handlers:", logger.handlers)
    for logger_name in "mylib.module_a", "mylib.module_b":
        ml = getLogger(logger_name)
        print(ml, "handlers:", ml.handlers)
    print()
```

The `module_a.py` and `module_b.py` files contain classes `A` and `B`, respectively, which have methods that log messages at different levels. For example, `module_a.py` contains:

```py
from logging import getLogger

logger = getLogger(__name__)


class A:
    def __init__(self):
        logger.debug("Initialising A")

    def info(self):
        logger.info("Info from A")

    def warn(self):
        logger.warn("Warning from A")
```

Similarly, `module_b.py` contains:

```py
from logging import getLogger

logger = getLogger(__name__)


class B:
    def __init__(self):
        logger.debug("Initialising B")

    def info(self):
        logger.info("Info from B")

    def warn(self):
        logger.warn("Warning from B")
```

## Running the scripts

### script1.py

This script is used to run the `mylib` package and demonstrate the logging configuration. It imports the `run` function from `mylib` and calls it.

```py
from mylib import run

run()
```

When you run `script1.py`, it will output the logging configuration and the log messages from the `A` and `B` classes. The output will look something like this:

```output
<RootLogger root (WARNING)> handlers: []
<Logger mylib (WARNING)> handlers: []
<Logger mylib.module_a (WARNING)> handlers: []
<Logger mylib.module_b (WARNING)> handlers: []

Warning from A
Warning from B
```

This output shows that the root logger and the `mylib` logger have no handlers, and the log messages from the `A` and `B` classes are logged at the WARNING level.

### script2.py

```py
import logging

from mylib import run

root_logger = logging.getLogger()
root_logger.addHandler(logging.FileHandler("./test.log"))

run()
```

This script adds a `FileHandler` to the root logger, which will log messages to a file named `test.log`. When you run `script2.py`, it will create the `test.log` file and log the messages from the `A` and `B` classes.

On running `script2.py`, the output on the console will be:

```output
<RootLogger root (WARNING)> handlers: [<FileHandler path_to_your_project\test.log (NOTSET)>]
<Logger mylib (WARNING)> handlers: []
<Logger mylib.module_a (WARNING)> handlers: []
<Logger mylib.module_b (WARNING)> handlers: []
```

This output differs from that of `script1.py` because the root logger now has a `FileHandler` that will log messages to the `test.log` file. The messages stored in the `test.log` file will look like this:

```output
Warning from A
Warning from B
```

### script3.py

```py
import logging

from mylib import run

root_logger = logging.getLogger()
root_logger.setLevel(logging.DEBUG)

run()
```

This script sets the logging level of the root logger to DEBUG, which means that all log messages of level DEBUG and above will be logged. When you run `script3.py`, it will output the following on the console:

```output
<RootLogger root (DEBUG)> handlers: []
<Logger mylib (DEBUG)> handlers: []
<Logger mylib.module_a (DEBUG)> handlers: []
<Logger mylib.module_b (DEBUG)> handlers: []

Warning from A
Warning from B
```

This output shows that the root logger and the `mylib` logger now have their levels set to DEBUG, which means that all log messages of level DEBUG and above will be logged. However, since no handlers are added, the messages will not be sent anywhere except as output to the console only when the script is run. Notice that this output is similar to that of `script1.py`, but the log level is now DEBUG.

### script4.py

```py
import logging

from mylib import run

logging.basicConfig()

run()
```

This script uses the `basicConfig()` method to configure the logging system with default settings. When you run `script4.py`, it will output the following on the console:

```output
<RootLogger root (WARNING)> handlers: [<StreamHandler <stderr> (NOTSET)>]
<Logger mylib (WARNING)> handlers: []
<Logger mylib.module_a (WARNING)> handlers: []
<Logger mylib.module_b (WARNING)> handlers: []

WARNING:mylib.module_a:Warning from A
WARNING:mylib.module_b:Warning from B
```

This output shows that the root logger now has a `StreamHandler` that sends log messages to the console (stderr). The log messages from the `A` and `B` classes are logged at the WARNING level, which is the default level set by `basicConfig()`.
