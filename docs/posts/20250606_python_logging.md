---
date: 2025-06-06
authors:
  - SaranjeetKaur
categories:
  - Technology
tags:
  - Python
  - Logging
---


# **Logging in Python**

When trying to understand what is happening with a Python code or even when debugging, we often end up adding a bunch of `print()` statements all over the code. While this might provide some idea, it is often not structured and is a bit ad-hoc. Python's `logging` module helps provide a more structured approach to tracking events that happen when the software runs. In this blog, we discuss about `logging` and provide some examples of the same.

<!-- more -->

## Levels of logging

To begin with, we can create a logger using `logger = getLogger(__name__)` and then call the logger methods. These methods denotes the level/severity of the event they are tracking. Depending on which level is configured (default is `WARNING`), the events of only that level or higher will be tracked. Below is a list of standard logging levels:

| **Level** | **Numeric value** | **Use** |
| --- | --- | --- |
| NOTSET | 0 | Placeholder  |
| DEBUG | 10 | Helps diagnose problems with detailed information. |
| INFO | 20 | Confirms that things are working as expected. |
| WARNING | 30 | Indicates either something unexpected occurred or there will be a problem in the near future. The software is still working as expected.|
| ERROR | 40 | A more serious problem and the software has not been able to perform some function. |
| CRITICAL | 50 | A serious error which indicates that the program itself may be unable to continue running. |

The [`setLevel`(level)](https://docs.python.org/3/library/logging.html#logging.Logger.setLevel) method is used to set the threshold of a logger to a specified `level`. In the example code below, the logger level is set to INFO which implies, the logger will handle only INFO, WARNING, ERROR, and CRITICAL messages and ignore the DEBUG messages as they are less severe than INFO.

```py
import logging
logger = logging.getLogger('example') # create a logger
logger.setLevel(logging.INFO) # set the logger level to INFO
```

## Handlers

Handlers are used to specify the destination where the log messages generated by loggers should go. For example, the log records maybe send to a log file, or to an email address, or even to the console. It is possible to have multiple handlers for one logger, where each handler sends messages of a specific level to a specific location. The `addHandler()` method can be used to add handler objects to logger objects. Some examples of handlers are listed below:

| **Handler** | **Use** |
| --- | --- |
| StreamHandler | Sends log messages to the console (stdout) or stderr. |
| FileHandler | Sends log messages to a file. |
| RotatingFileHandler | Sends log messages to a file, rotating the file when it reaches a certain size. |
| TimedRotatingFileHandler | Sends log messages to a file, rotating the file at regular time intervals. |
| SMTPHandler | Sends log messages via email. |
| HTTPHandler | Sends log messages to a web server. |
| NullHandler | A handler that does nothing, used to avoid "No handlers could be found" warnings. |

In the example below, we create a logger and add a `StreamHandler` to it. The handler is set to log messages of level INFO and above to the console.

```py
import logging
logger = logging.getLogger('example')  # create a logger
handler = logging.StreamHandler()  # create a handler
handler.setLevel(logging.INFO)  # set the handler level to INFO
logger.addHandler(handler)  # add the handler to the logger
```

Note: Levels can also be set for handlers, which means that the handler will only process messages of that level or higher. If a logger has multiple handlers, each handler can have its own level.

## Demonstration

This demonstration is based on a Python logging exercise by Chris Cave-Ayland, and it is available on [GitHub](https://github.com/cc-a/python_logging_exercises). It covers some common logging scenarios and how to implement them using Python's logging module.

??? "Directory Structure"

    The directory structure for this demonstration is as follows: <!-- markdownlint-disable-line MD046 -->

    ```plaintext
    ├── mylib/
    │   ├── __init__.py
    │   ├── module_a.py
    │   └── module_b.py
    ├── README.md
    └── script1.py
    └── script2.py
    .
    .
    .
    └── script10.py
    ```

The `mylib` directory contains two modules, `module_a.py` and `module_b.py`, which contain functions that will be logged. The `script1.py` to `script10.py` files are scripts that call the functions from these modules.

The `mylib/__init__.py` file is used to initialize the `mylib` package and contains the following code:

```py
from logging import getLogger

from .module_a import A
from .module_b import B

logger = getLogger(__name__)


def run():
    print_logging_config()
    a = A()
    a.warn()
    a.info()
    b = B()
    b.warn()
    b.info()


def print_logging_config():
    rl = getLogger()
    print(rl, "handlers:", rl.handlers)
    print(logger, "handlers:", logger.handlers)
    for logger_name in "mylib.module_a", "mylib.module_b":
        ml = getLogger(logger_name)
        print(ml, "handlers:", ml.handlers)
    print()
```

The `module_a.py` and `module_b.py` files contain classes `A` and `B`, respectively, which have methods that log messages at different levels. For example, `module_a.py` contains:

```py
from logging import getLogger

logger = getLogger(__name__)


class A:
    def __init__(self):
        logger.debug("Initialising A")

    def info(self):
        logger.info("Info from A")

    def warn(self):
        logger.warn("Warning from A")
```

Similarly, `module_b.py` contains:

```py
from logging import getLogger

logger = getLogger(__name__)


class B:
    def __init__(self):
        logger.debug("Initialising B")

    def info(self):
        logger.info("Info from B")

    def warn(self):
        logger.warn("Warning from B")
```

## Running the scripts

### script1.py

This script is used to run the `mylib` package and demonstrate the logging configuration. It imports the `run` function from `mylib` and calls it.

```py
from mylib import run

run()
```

When you run `script1.py`, it will output the logging configuration and the log messages from the `A` and `B` classes. The output will look something like this:

```plaintext
root handlers: []
mylib.module_a handlers: []
mylib.module_b handlers: []
mylib handlers: [<StreamHandler <stderr> (NOTSET)>]
mylib.module_a handlers: [<StreamHandler <stderr> (NOTSET)>]
mylib.module_b handlers: [<StreamHandler <stderr> (NOTSET)>]
Initialising A
Warning from A
Info from A
Initialising B
Warning from B
Info from B
```

This output shows that the root logger and the `mylib` logger have no handlers, while the `mylib.module_a` and `mylib.module_b` loggers have a `StreamHandler` that outputs to stderr. The log messages from the `A` and `B` classes are displayed as expected.
